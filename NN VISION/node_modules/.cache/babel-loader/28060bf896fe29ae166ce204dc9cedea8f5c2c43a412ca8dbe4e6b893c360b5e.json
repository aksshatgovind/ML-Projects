{"ast":null,"code":"// import React, { useState, useEffect } from 'react';\n\n// function NeuralNetwork({ inputValues }) {\n//   const [hiddenNodes, setHiddenNodes] = useState([\n//     { id: 'hidden1', x: 300, y: 150, value: 0 },\n//     { id: 'hidden2', x: 300, y: 250, value: 0 },\n//     { id: 'hidden3', x: 300, y: 350, value: 0 },\n//     { id: 'hidden4', x: 300, y: 450, value: 0 },\n//     // Default hidden nodes\n//   ]);\n//   const [outputNode, setOutputNode] = useState({ id: 'output', x: 700, y: 300, activation: 0, color: 'red' }); // Output node\n//   const [inputNodeValues, setInputNodeValues] = useState({\n//     input1: 0,\n//     input2: 0,\n//     input3: 0,\n//     // Default input values\n//   });\n//   const [inputToHiddenWeights, setInputToHiddenWeights] = useState(() => {\n//     const weights = [];\n//     for (let i = 0; i < 4; i++) {\n//       weights.push(Array(3).fill(0)); // Initialize each row with 3 weights with default value 0\n//     }\n//     return weights;\n//   });\n//   const [edges, setEdges] = useState([]);\n//   const [inputsComplete, setInputsComplete] = useState(false);\n\n//   // Function to generate random edges with weights\n//   const generateRandomEdges = () => {\n//     const edges = [];\n//     for (let i = 0; i < hiddenNodes.length; i++) {\n//       const target = hiddenNodes[i].id;\n//       for (let j = 0; j < 3; j++) {\n//         const source = `input${j + 1}`;\n//         const weight = inputToHiddenWeights[i][j]; // Use the weight from inputToHiddenWeights\n//         edges.push({ source, target, weight });\n//       }\n//     }\n//     return edges;\n//   };\n\n//   // Function to calculate the value of a hidden node\n//   const calculateHiddenNodeValue = (hiddenNode, inputNodeValues, edges) => {\n//     const value = edges\n//       .filter(edge => edge.target === hiddenNode.id)\n//       .reduce((acc, edge) => {\n//         const inputValue = inputNodeValues[edge.source];\n//         const weight = edge.weight;\n//         return acc + inputValue * weight;\n//       }, 0);\n//     // Apply ReLU activation function\n//     return value >= 0 ? value : 0;\n//   };\n\n//   useEffect(() => {\n//     // Initialize input values whenever inputValues prop changes\n//     setInputNodeValues(inputValues);\n//   }, [inputValues]);\n\n//   useEffect(() => {\n//     // Update hidden node values whenever input node values change\n//     if (inputsComplete) {\n//       const updatedHiddenNodes = hiddenNodes.map((hiddenNode, index) => {\n//         const value = calculateHiddenNodeValue(hiddenNode, inputNodeValues, edges);\n//         return { ...hiddenNode, value };\n//       });\n//       setHiddenNodes(updatedHiddenNodes);\n//     }\n//   }, [inputNodeValues, inputsComplete, edges, hiddenNodes]);\n\n//   useEffect(() => {\n//     // Generate random edges whenever input values or hidden nodes change\n//     setEdges(generateRandomEdges());\n//   }, [inputNodeValues, hiddenNodes, inputToHiddenWeights]);\n\n//   const handleInputChange = (e, inputName) => {\n//     setInputNodeValues(prevState => ({ ...prevState, [inputName]: parseFloat(e.target.value) }));\n//   };\n\n//   const handleInputComplete = () => {\n//     setInputsComplete(true);\n//   };\n\n//   const handleWeightChange = (e, rowIndex, colIndex) => {\n//     const newWeights = [...inputToHiddenWeights];\n//     newWeights[rowIndex][colIndex] = parseFloat(e.target.value);\n//     setInputToHiddenWeights(newWeights);\n//   };\n\n//   return (\n//     <div className=\"NeuralNetwork\">\n//       <div className=\"t\">Perceptron</div>\n//       <svg width=\"1200\" height=\"800\">\n//         {/* Render edges from input nodes to hidden nodes */}\n//         {[...Array(3).keys()].map((i) => (\n//           [...Array(4).keys()].map((j) => (\n//             <g key={`input-hidden-${i}-${j}`}>\n//               <line\n//                 x1={130}\n//                 y1={(i + 1) * 210}\n//                 x2={370}\n//                 y2={(j + 1) * 175}\n//                 stroke=\"black\"\n//                 strokeWidth=\"2\"\n//                 markerEnd=\"url(#arrowhead)\"\n//               />\n//               <foreignObject x={(130 + 350) / 2 - 1} y={(i + 1) * 185 + ((j + 1) * 210 - (i + 1) * 210) / 2 - 10} width=\"20\" height=\"20\">\n//                 <input\n//                   type=\"number\"\n//                   style={{ width: \"20px\", height: \"20px\" }}\n//                   value={inputToHiddenWeights[j][i]} // Adjusted indexing for weights array\n//                   onChange={(e) => handleWeightChange(e, j, i)} // Pass rowIndex and colIndex\n//                 />\n//               </foreignObject>\n//             </g>\n//           ))\n//         ))}\n\n//         {/* Render edges from hidden nodes to output node */}\n//         {[...Array(4).keys()].map((index) => (\n//           <g key={`hidden-output-${index}`}>\n//             <line\n//               x1={429}\n//               y1={(index + 1) * 176}\n//               x2={619}\n//               y2={400}\n//               stroke=\"black\"\n//               strokeWidth=\"2\"\n//               markerEnd=\"url(#arrowhead)\"\n//             />\n//             <foreignObject x={(400 + 650) / 2 - 10} y={(index + 1) * 190 + (410 - (index + 1) * 210) / 2 - 10} width=\"20\" height=\"20\">\n//               <input type=\"number\" style={{ width: \"20px\", height: \"20px\" }} />\n//             </foreignObject>\n//           </g>\n//         ))}\n\n//         {/* Render input nodes */}\n//         {Object.keys(inputNodeValues).map((input, index) => (\n//           <g key={input}>\n//             <circle cx={100} cy={(index + 1) * 210} r=\"30\" fill=\"green\" opacity=\"0.96\"/>\n//             <text x={100} y={(index + 1) * 210} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">{`I ${index + 1}`}</text>\n//             {/* Display input value dynamically */}\n//             <text x={100} y={(index + 1) * 210 + 50} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">{inputNodeValues[input]}</text>\n//           </g>\n//         ))}\n\n//         {/* Render hidden nodes */}\n//         {hiddenNodes.map((node, index) => (\n//           <g key={`hidden-${index}`}>\n//             <circle cx={node.x} cy={node.y} r=\"30\" fill=\"blue\" opacity=\"0.96\"/>\n//             <text x={node.x} y={node.y} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">{`H ${index + 1}`}</text>\n//             {/* Display hidden node value dynamically */}\n//             <text x={node.x} y={node.y + 40} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">{node.value.toFixed(2)}</text>\n//           </g>\n//         ))}\n\n//         {/* Render output node */}\n//         <g key={`output`}>\n//           <circle cx={outputNode.x} cy={outputNode.y} r=\"30\" fill={outputNode.color} opacity=\"0.96\"/>\n//           <text x={outputNode.x} y={outputNode.y} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">Out</text>\n//           {/* Display output value dynamically rounded to 2 decimal places */}\n//           <text x={outputNode.x} y={outputNode.y + 50} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">\n//             {outputNode.activation.toFixed(2)}\n//           </text>\n//         </g>\n\n//         {/* Arrowhead marker */}\n//         <marker\n//           id=\"arrowhead\"\n//           markerWidth=\"10\"\n//           markerHeight=\"10\"\n//           refX=\"8\"\n//           refY=\"3\"\n//           orient=\"auto\"\n//           fill=\"black\"\n//         >\n//           <polygon points=\"0 0, 10 3, 0 6\" />\n//         </marker>\n//       </svg>\n\n//       {!inputsComplete && <button onClick={handleInputComplete}>Calculate Hidden Values</button>}\n//     </div>\n//   );\n// }\n\n// export default NeuralNetwork;","map":{"version":3,"names":[],"sources":["/Users/coding/Library/Mobile Documents/com~apple~CloudDocs/Documents/vs/ML-Projects/NN VISION/src/components/NeuralNetwork.js"],"sourcesContent":["// import React, { useState, useEffect } from 'react';\n\n// function NeuralNetwork({ inputValues }) {\n//   const [hiddenNodes, setHiddenNodes] = useState([\n//     { id: 'hidden1', x: 300, y: 150, value: 0 },\n//     { id: 'hidden2', x: 300, y: 250, value: 0 },\n//     { id: 'hidden3', x: 300, y: 350, value: 0 },\n//     { id: 'hidden4', x: 300, y: 450, value: 0 },\n//     // Default hidden nodes\n//   ]);\n//   const [outputNode, setOutputNode] = useState({ id: 'output', x: 700, y: 300, activation: 0, color: 'red' }); // Output node\n//   const [inputNodeValues, setInputNodeValues] = useState({\n//     input1: 0,\n//     input2: 0,\n//     input3: 0,\n//     // Default input values\n//   });\n//   const [inputToHiddenWeights, setInputToHiddenWeights] = useState(() => {\n//     const weights = [];\n//     for (let i = 0; i < 4; i++) {\n//       weights.push(Array(3).fill(0)); // Initialize each row with 3 weights with default value 0\n//     }\n//     return weights;\n//   });\n//   const [edges, setEdges] = useState([]);\n//   const [inputsComplete, setInputsComplete] = useState(false);\n\n//   // Function to generate random edges with weights\n//   const generateRandomEdges = () => {\n//     const edges = [];\n//     for (let i = 0; i < hiddenNodes.length; i++) {\n//       const target = hiddenNodes[i].id;\n//       for (let j = 0; j < 3; j++) {\n//         const source = `input${j + 1}`;\n//         const weight = inputToHiddenWeights[i][j]; // Use the weight from inputToHiddenWeights\n//         edges.push({ source, target, weight });\n//       }\n//     }\n//     return edges;\n//   };\n\n//   // Function to calculate the value of a hidden node\n//   const calculateHiddenNodeValue = (hiddenNode, inputNodeValues, edges) => {\n//     const value = edges\n//       .filter(edge => edge.target === hiddenNode.id)\n//       .reduce((acc, edge) => {\n//         const inputValue = inputNodeValues[edge.source];\n//         const weight = edge.weight;\n//         return acc + inputValue * weight;\n//       }, 0);\n//     // Apply ReLU activation function\n//     return value >= 0 ? value : 0;\n//   };\n\n//   useEffect(() => {\n//     // Initialize input values whenever inputValues prop changes\n//     setInputNodeValues(inputValues);\n//   }, [inputValues]);\n\n//   useEffect(() => {\n//     // Update hidden node values whenever input node values change\n//     if (inputsComplete) {\n//       const updatedHiddenNodes = hiddenNodes.map((hiddenNode, index) => {\n//         const value = calculateHiddenNodeValue(hiddenNode, inputNodeValues, edges);\n//         return { ...hiddenNode, value };\n//       });\n//       setHiddenNodes(updatedHiddenNodes);\n//     }\n//   }, [inputNodeValues, inputsComplete, edges, hiddenNodes]);\n\n//   useEffect(() => {\n//     // Generate random edges whenever input values or hidden nodes change\n//     setEdges(generateRandomEdges());\n//   }, [inputNodeValues, hiddenNodes, inputToHiddenWeights]);\n\n//   const handleInputChange = (e, inputName) => {\n//     setInputNodeValues(prevState => ({ ...prevState, [inputName]: parseFloat(e.target.value) }));\n//   };\n\n//   const handleInputComplete = () => {\n//     setInputsComplete(true);\n//   };\n\n//   const handleWeightChange = (e, rowIndex, colIndex) => {\n//     const newWeights = [...inputToHiddenWeights];\n//     newWeights[rowIndex][colIndex] = parseFloat(e.target.value);\n//     setInputToHiddenWeights(newWeights);\n//   };\n\n//   return (\n//     <div className=\"NeuralNetwork\">\n//       <div className=\"t\">Perceptron</div>\n//       <svg width=\"1200\" height=\"800\">\n//         {/* Render edges from input nodes to hidden nodes */}\n//         {[...Array(3).keys()].map((i) => (\n//           [...Array(4).keys()].map((j) => (\n//             <g key={`input-hidden-${i}-${j}`}>\n//               <line\n//                 x1={130}\n//                 y1={(i + 1) * 210}\n//                 x2={370}\n//                 y2={(j + 1) * 175}\n//                 stroke=\"black\"\n//                 strokeWidth=\"2\"\n//                 markerEnd=\"url(#arrowhead)\"\n//               />\n//               <foreignObject x={(130 + 350) / 2 - 1} y={(i + 1) * 185 + ((j + 1) * 210 - (i + 1) * 210) / 2 - 10} width=\"20\" height=\"20\">\n//                 <input\n//                   type=\"number\"\n//                   style={{ width: \"20px\", height: \"20px\" }}\n//                   value={inputToHiddenWeights[j][i]} // Adjusted indexing for weights array\n//                   onChange={(e) => handleWeightChange(e, j, i)} // Pass rowIndex and colIndex\n//                 />\n//               </foreignObject>\n//             </g>\n//           ))\n//         ))}\n\n\n//         {/* Render edges from hidden nodes to output node */}\n//         {[...Array(4).keys()].map((index) => (\n//           <g key={`hidden-output-${index}`}>\n//             <line\n//               x1={429}\n//               y1={(index + 1) * 176}\n//               x2={619}\n//               y2={400}\n//               stroke=\"black\"\n//               strokeWidth=\"2\"\n//               markerEnd=\"url(#arrowhead)\"\n//             />\n//             <foreignObject x={(400 + 650) / 2 - 10} y={(index + 1) * 190 + (410 - (index + 1) * 210) / 2 - 10} width=\"20\" height=\"20\">\n//               <input type=\"number\" style={{ width: \"20px\", height: \"20px\" }} />\n//             </foreignObject>\n//           </g>\n//         ))}\n\n//         {/* Render input nodes */}\n//         {Object.keys(inputNodeValues).map((input, index) => (\n//           <g key={input}>\n//             <circle cx={100} cy={(index + 1) * 210} r=\"30\" fill=\"green\" opacity=\"0.96\"/>\n//             <text x={100} y={(index + 1) * 210} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">{`I ${index + 1}`}</text>\n//             {/* Display input value dynamically */}\n//             <text x={100} y={(index + 1) * 210 + 50} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">{inputNodeValues[input]}</text>\n//           </g>\n//         ))}\n\n//         {/* Render hidden nodes */}\n//         {hiddenNodes.map((node, index) => (\n//           <g key={`hidden-${index}`}>\n//             <circle cx={node.x} cy={node.y} r=\"30\" fill=\"blue\" opacity=\"0.96\"/>\n//             <text x={node.x} y={node.y} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">{`H ${index + 1}`}</text>\n//             {/* Display hidden node value dynamically */}\n//             <text x={node.x} y={node.y + 40} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">{node.value.toFixed(2)}</text>\n//           </g>\n//         ))}\n\n//         {/* Render output node */}\n//         <g key={`output`}>\n//           <circle cx={outputNode.x} cy={outputNode.y} r=\"30\" fill={outputNode.color} opacity=\"0.96\"/>\n//           <text x={outputNode.x} y={outputNode.y} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"central\">Out</text>\n//           {/* Display output value dynamically rounded to 2 decimal places */}\n//           <text x={outputNode.x} y={outputNode.y + 50} fill=\"black\" textAnchor=\"middle\" alignmentBaseline=\"central\">\n//             {outputNode.activation.toFixed(2)}\n//           </text>\n//         </g>\n\n//         {/* Arrowhead marker */}\n//         <marker\n//           id=\"arrowhead\"\n//           markerWidth=\"10\"\n//           markerHeight=\"10\"\n//           refX=\"8\"\n//           refY=\"3\"\n//           orient=\"auto\"\n//           fill=\"black\"\n//         >\n//           <polygon points=\"0 0, 10 3, 0 6\" />\n//         </marker>\n//       </svg>\n\n//       {!inputsComplete && <button onClick={handleInputComplete}>Calculate Hidden Values</button>}\n//     </div>\n//   );\n// }\n\n// export default NeuralNetwork;\n\n\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}